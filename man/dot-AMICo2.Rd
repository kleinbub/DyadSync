% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sync_AMICo2_RC.R
\name{.AMICo2}
\alias{.AMICo2}
\title{v2RC0.4
This is just a packetized version of Amico_2_v4.R
please go there to make edits}
\usage{
.AMICo2(
  signal,
  lagSec,
  weightMalus = 50,
  match_threshold = 0,
  minSizeSec = 4,
  outputName = "AMICo2",
  maxPeakDuration = "hrt",
  interval_sec = 15,
  sgol_p,
  sgol_n,
  correctionRangeSeconds,
  minPeakAmplitude
)
}
\arguments{
\item{signal}{}

\item{lagSec}{}

\item{weightMalus}{}

\item{match_threshold}{}

\item{minSizeSec}{}

\item{outputName}{}

\item{maxPeakDuration}{}

\item{interval_sec}{}

\item{sgol_p}{}

\item{sgol_n}{}

\item{correctionRangeSeconds}{}

\item{minPeakAmplitude}{}
}
\description{
Title
}
\examples{
find triangles
good triangles start with valleys. if not delete first element
from bool and from all list elements of pv1 and pv2
Interpola entrambi dalla v a sinistra fino a p e da p fino a hrt/v a destra
a logistic weight is applied according to the ratio
of the longer and the shorter peaks
if the longer is twice the shorter the malus is 0.7
if it's 4 time, the malus is 0.5
see them all: 
REGOLE: ciascuna riga e ciascuna colonna possono essere matchate una sola volta
inoltre non è possibile incrociare i match, se r2-c3, r3-c1 non è ammesso.
Qua l'algoritmo crea una copia vuota di M, e comincia a popolarla iterativamente
col valore più alto tra:
  - la cella nella stessa riga ma colonna precedente
  - la cella nella stessa colonna ma riga precedente
  - la cella stessa + la cella diagonale precedente

Questo permette di ottenere per ciascun match-riga colonna il valore di
similarità cumulativo di quella scelta più la diagonale precedente, per trovare
la soluzione che massimizza la similarità globale, e non del singolo picco.
Ora l'algoritmo procede al contrario, dall'angolo alto dx, ovvero dai valori
più alti della matrice. Per ciascuna riga e colonna trova il massimo
(che implica che la somma dei valori ammessi precedenti sia massimo)
salva quel valore, ed elimina tutto su quella riga e quella colonna (perché
sono già stati scartati)
x[1] per pp1 e x[2] per pp2 rappresentano l'indice del picco selezionato
now now now
we know the similarity in proximity of the peaks. What about in between?
Proposal [a]: we use the same logic! interpolate the inbetweens, normalize them
and calculate the similarity. 
 qua entrambe le serie sono più lunghe di 1, ma sono troppo corte per calcolare
la sincro. Oppure una valley è usata 2 volte, mentre l'altro segnale ha della roba in mezzo

    /\  /\
s1 /  \/  \

   /\     /\
s2/  v\__/  \

In alternativa possiamo semplicemente stretchare i due punti del segnale
con la roba in mezzo al loro midpoint:
Now xbest is done. Create the 2 interpolated series, sync & lag
XBEST guide:
row: the peak number of s1 wich was matched
col: the peak number of s2
similarity: some similarity computation
lag: the delta between the sample of p1 and p2
a1, p1, b1: sample position of onset, peak, and end of a feature
a2, p2, b2: the same for s2
a, b: the average start and end between s1 and s2
ta, tb: the time corresponding to a and b
}
